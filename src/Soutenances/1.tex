\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{multimedia}
\usepackage[top=3cm, bottom=4cm, left=3cm, right=3cm, a4paper]{geometry}
\usepackage{lipsum}
\usepackage{caption}
\usepackage{fancyhdr}
\usepackage{tabto}
\usepackage{xcolor}
\usepackage{array}
\usepackage{enumitem}
\usepackage{eurosym}
\usepackage{xcolor}
\usepackage{blindtext}
\definecolor{back}{rgb}{0.15, 0.15, 0.15}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{multirow}

\usepackage{listings}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{whiteback}{rgb}{0.95, 0.95, 0.95}

\lstset{
language=c,
basicstyle=\footnotesize\ttfamily,
numbers=left,
numberstyle=\tiny,
numbersep=5pt,
tabsize=2,
extendedchars=true,
breaklines=true,
frame=b,
stringstyle=\color{mygreen}\ttfamily,
showspaces=false,
showtabs=false,
xleftmargin=0pt,
xrightmargin=0pt,
columns=fullflexible,
framexleftmargin=15pt,
framexrightmargin=0pt,
framexbottommargin=10pt,
framextopmargin=15pt,
commentstyle=\color{mygreen},
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
showstringspaces=false,
morekeywords={ abstract, event, new, struct,
as, explicit, null, switch,
base, extern, object, this,
bool, false, operator, throw,
break, finally, out, true,
byte, fixed, override, try,
case, float, params, typeof,
catch, for, private, uint,
char, foreach, protected, ulong,
checked, goto, public, unchecked,
class, if, readonly, unsafe,
const, implicit, ref, ushort,
continue, in, return, using,
decimal, int, sbyte, virtual,
default, interface, sealed, volatile,
delegate, internal, short, void,
do, is, sizeof, while,
double, lock, stackalloc,
else, long, static,
enum, namespace, string},
keywordstyle=\color{blue},
identifierstyle=\color{back},
backgroundcolor=\color{whiteback},
}

\setcounter{page}{1}
\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\headrule}{{\color{gray}\vskip-\footruleskip\vskip-\footrulewidth \hrule width\headwidth height\footrulewidth\vskip\footruleskip}}
\renewcommand{\footrule}{{\color{gray}\vskip-\footruleskip\vskip-\footrulewidth \hrule width\headwidth height\footrulewidth\vskip\footruleskip}}
\renewcommand{\footrulewidth}{0.5pt}

\rhead{}
\lhead{}


\usepackage{tocloft}


\begin{document}

    \headsep = 12pt
    \vspace*{\stretch{1}}
		\begin{center}
			\begin{LARGE}
				\textbf{Rapport de soutenance}
				\paragraph{}Charles\hspace{0.7cm}Quentin\hspace{0.7cm}Maxime\hspace{0.7cm}Nathan
			\end{LARGE}
		\end{center}
		\vspace{1.5cm}
		\begin{center}
			\includegraphics[scale=0.3]{LogoBitarrays.png}
    		\paragraph{} Par BITARRAYS
		\end{center}
		\vspace*{\stretch{1}}
	
	\newpage
    \pagestyle{fancy}
    \fancyhf{}
    \lhead{Rapport de soutenance\vspace{0.25cm}}
    \rhead{Table des matières}
    \cfoot{\thepage}
    \chead{\includegraphics[scale=0.05]{LogoBitarrays.png}}
    \vspace*{2.5cm}
    \tableofcontents
    
\newpage
\rhead{\textit{Prologue}\vspace{0.25cm}}
\cfoot{\thepage}
\chead{\includegraphics[scale=0.05]{LogoBitarrays.png}}
\vspace*{5cm}
\begin{huge}
\hspace{-0.9cm}
\textbf{\emph{Prologue}}
\end{huge}
\vspace*{1cm}
\vspace{0.4cm}
	\paragraph{}
    à travers ce cahier des charges, notre équipe présente ses ambitions pour réaliser le projet du deuxième semestre de l'EPITA, qui durera environ 6 mois, rythmé par trois soutenances intermédiaires et une finale.
	
	\paragraph{}
    Nous étions huit étudiants, attirés par la création d'un groupe en commun. Suite à un débat d'idées et au fil des discussions, les deux groupes se sont constitués naturellement, en fonction des idées qui ont été proposées. Ainsi, nous avons créé un groupe de 4 personnes très inspirées par l'idée d'un jeu d'énigme. Cela nous obligera à réfléchir individuellement à des énigmes innovantes, nouvelles, avec un niveau de difficulté suffisant pour permettre l'amusement et la durabilité de notre jeu.
	
	\paragraph{}
    Nous allons apprendre à communiquer et à s'adapter aux différents caractères des membres de notre groupe. Nous avons, par expérience, déjà compris qu'un projet de groupe est un réel défi au niveau humain mais ce projet s'annonce encore plus complexe.
    Nous sommes tous très motivés par la création de ce jeu.
	
	\paragraph{}
    Notre investissement se devra d'être maximal. Nous allons nous découvrir dans les moments durs et stressants qui rythmeront nos 6 prochains mois et nous apprendrons à travailler efficacement en équipe.

	\paragraph{}
    Nous allons maintenant expliquer les différents objectifs de notre projet, de la création, à la réalisation en passant par les coûts et la rentabilité ainsi que le respect de nos délais.

\newpage
\lhead{Rapport de soutenance\vspace{0.25cm}}
\rhead{\textit{Présentation}\vspace{0.25cm}}
\vspace*{\stretch{1}}
\section{Présentations}
\subsection{Les membres}
\subsubsection{Quentin "Scout" FISCH}
\paragraph{}J'ai vraiment découvert ma passion pour l'informatique par le biais de TP effectués en Sciences de L'ingénieur en Première et Terminale. J'ai donc décider d'étudier car je suis très intéressé en ce qui concerne la robotique et le développement de technologies dans les systèmes embarqués. Ce projet sera pour moi mon premier jeu à créer de A à Z et m'apprendra comment gérer un tel projet en respectant des deadlines et diverses contraintes. Je suis ainsi très motivé à sortir le meilleur projet possible et développer mes compétences en informatique.

\subsubsection{Maxime "Maxmad" MADRAU}
\paragraph{}Passionné d'informatique depuis toujours, j'ai commencé a développer des programmes simples très tôt dans mon enfance. J'ai par la suite appris des langages comme le Python, le Lua, le Javascript, le Swift, et les langages web comme le HTML et le CSS. Mes domaines de prédilection sont les applications mobiles, les bases de données et le client/serveur. La conception de jeux vidéo a pour moi commencé en année de Terminale, pour le Bac d'ISN, où on a du développer un jeu en Python avec la bibliothèque Pygame. Ce projet m'a permis de découvrir le développement de projets dans le respect de contraintes de temps, de ressources ainsi que de licences et de droits.

\subsubsection{Charles "Draze" SIMON-MEUNIER}
\paragraph{}Passionné d'informatique depuis mes années du collège ou j'ai commencé à développer des serveurs sur Minecraft, EPITA est pour moi une révélation. Une école avec une formation permettant d'atteindre le statut d'ingénieur ainsi que des compétences en informatique plus que confortables est pour moi le cursus idéal. J'ai appris par moi même certains langages comme le HTML/CSS, Java et aujourd'hui je me perfectionne et corrige mes défauts grâce à l'école. Ce projet devrait m'apporter à titre personnel beaucoup d'expérience, autant au niveau humain que dans les compétences informatiques.

\subsubsection{Nathan "Goruza" AVÉ}

\vspace*{\stretch{1}}

\newpage


\subsection{Le groupe}

\paragraph{}Nous avons créé notre groupe en reprenant les membres avec qui nous avions travaillé l'année dernière car l'entente était très bonne tout comme l'efficacité au sein du groupe. De plus, nous avons déjà quelques projets de groupe à notre actif ce qui permet de connaître les points forts et faibles de chacun. Malheureusement nous n'étions que 3 et il fallait trouver un dernier membre pour former un groupe de 4 personnes. Nathan était le bon candidat car nous nous connaissons bien et le travail pourrait alors être efficace.
\paragraph{}

\newpage

\rhead{\textit{Pré-traitement}\vspace{0.25cm}}
\section{Traitement de l'image (pré-traitement)}

\subsection{Ce que nous devions faire}

\paragraph{}Pour traiter les images de la meilleure des façons, il fallait penser à réaliser un pré traitement sur ces dernières pour que notre segmentation soit la meilleure possible. Il fallait réaliser un niveau de gris, une binarisation et appliquer des filtres permettant de réduire le bruit sur l'image. Toute cette partie est réalisée dans le fichier filters.c, contenu dans \textbf{"/src/ImageTreatment"}

\subsection{Le niveau de gris}

\paragraph{}Rien de compliqué pour réaliser cette fonction, il suffit de parcourir entièrement l'image et d'appliquer pour chacun des pixels une nouvelle valeur utilisant les valeurs de rouge, vert et bleu de chaque pixel. Les coefficients appliqués aux valeurs rouge, vert et bleu sont respectivement 0.3, 0.59, 0.11. Cela permet de créer un nouveau pixel avec cette nouvelle valeur pour sa valeur rouge, vert et bleu (pour obtenir un niveau de gris).

\paragraph{}Pour utiliser cette fonctionnalité dans notre programme, il suffit d'exécuter
\begin{lstlisting}
./Lamba grayscale "image_path" "destination_path"
\end{lstlisting}

$ IMAGE NORMALE VERS GRIS $

\subsection{Binarisation}

\paragraph{}Pour binariser l'image (c'est à dire ne laisser que des pixels blancs ou noirs), nous avons appliqué une condition simple sur chacun des pixels qui compose l'image. Nous faisons la moyenne des valeurs rouge, vert et bleu et vérifions sur cette dernière est supérieure ou non à 127. Si elle est supérieure, nous mettons un pixel blanc et un noir sinon. Il n'existe pas de commande pour appliquer ce filtre dans notre exécutable.
\paragraph{} Ce n'est pas ici la fonction la plus compliquée de notre code mais ce sont des éléments essentiels pour la suite.


\subsection{Réduction de bruit}

$ TODO $



\newpage
\rhead{\textit{Segmentation de l'image}\vspace{0.25cm}}
\section{Segmentation de l'image}
\subsection{Introduction}
    \paragraph{}
    Ce premier mois de projet nous a permis de commencer à implémenter des fonctionnalités primordiales pour la réalisation de notre projet final. En effet nous avons réalisé la segmentation des caractères, à reconnaître par la suite. \\
    Ce processus est complexe et crucial pour pouvoir fournir au programme de reconnaissance des caractères bien découpés et formalisés comme le dataset utilisé pour l'entraîner.
    
\subsection{Segmentation de caractères}
    \paragraph{}
    Comme dit précédemment, la segmentation du texte initial en caractères reconnaissables par le programme est une des parties sur laquelle nous nous sommes le plus penché durant ce premier mois.
    
    \subsubsection{Découpage des colonnes}
    \paragraph{}
    Si la détection des caractères est primordiale, elle n'est que le point final du chaîne d'opérations sur l'image initiale. La première étape du processus de segmentation est le découpage des colonnes. Par exemple, l'image présentée ci-dessous comporte deux colonnes, qu'il faut séparer pour pouvoir continuer le processus de segmentation. \\
    
    $IMAGE paragraph.png$
    
    \paragraph{}
    La détection des colonnes est un processus assez simple, qui tient compte de la "logique" d'organisation d'un texte. En effet, en tant qu'humains, nous distinguons deux colonnes comme des "colonnes" et non une suite de mots par l'espace situé entre les deux blocs qui est anormalement grand par rapport aux espaces présents entre les mots du texte.
    \par
    Ainsi, j'ai implémenté la même logique pour la segmentation, qui détecte un espace rempli de pixels blancs anormalement grand entre deux parties ne contenant pas uniquement des pixels blancs. Voici un aperçu du code implémenté:
    
    \begin{lstlisting}
    
    unsigned char fullWhite = 1;
    unsigned char firstCut = 1;
    int endText = -1; //Gets the first pixel (width wise) with full white width
    int beginingText = -1; //Gets the first pixel without full white height after several full white 
    lastLineWidth = 0.03 * img -> w;
    
		for (int i = 0; i < img -> w; i++) 
    {
        // Returns whether img's height is full of white pixels or not
        fullWhite = fullWhite(img, i);

        if (!fullWhite && firstCut)
        {   
            // Begins column cut
            beginingText = i;
            if (endText == -1 || lastLineWidth <= abs(endText - beginingText)){
                //Draw line to separate column
                for (int k = 0; k < img -> h; k++)
                {
                    pixel = SDL_MapRGB(img_copy -> format, 0, 255, 0);
                    putpixel(img_copy, beginingText, k, pixel);
                }   
            }
            firstCut = 0;
        }
        
        if(fullWhite && !firstCut) {
        
            // Ends column cut
            endText = i-1;
            int ii = i;
            do
            {
                fullWhite = fullWhite(img, ii);
                ii++;
            } while (fullWhite);
            
            if (ii - endText >= lastLineWidth || ii >= img -> w) {
                // Space is too big, draw line to separate
                for (int k = 0; k < img -> h; k++)
                {
                    pixel = SDL_MapRGB(img_copy -> format, 0, 255, 0);
                    putpixel(img_copy, i, k, pixel);
                }
            }
            firstCut = 1;
        }
    }	
	\end{lstlisting}
	
	\par
	Le principe est le suivant: on possède une variable \textit{fullWhite} qui indique si, pour un pixel donné (sur la largeur), tous les pixels sur la hauteur de l'image sont blancs. Cette variable est très importante, car combinée à \textit{firstCut}, on peut savoir si la partie de l'image où l'on se situe est du texte ou non. \textit{firstCut} permet de savoir si nous sommes en train de chercher le début d'une colonne (1 dans ce cas), ou si le début la colonne est déjà repéré et qu'on cherche donc la fin.
	
	\paragraph{}
	Ainsi le code devient plus compréhensible. En parcourant toute la largeur de l'image, on regarde à chaque fois si toute la hauteur de l'image est blanche. 
	\par
	Si c'est n'est pas cas et que nous cherchons le début d'une colonne, alors nous l'avons trouvé et pouvons dessiner une ligne verticale pour marquer le début de la colonne.
	\par
	Si cependant nous ne cherchons plus le début mais la fin d'une colonne et qu'on se trouve sur un pixel dont la hauteur de l'image est toute blanche, alors nous évaluons les possibilités que ce soit la fin de la colonne. On note \textit{endText} comme l'indice final temporaire du texte. On continue d'avancer dans la largeur de l'image jusqu'au prochain pixel qui n'est pas \textit{fullWhite}. Enfin, la distance entre ce nouveau pixel et \textit{endText} est comparée à une constant représentant 3\% de la largeur de l'image. Si l'écart est supérieur à cette constante, on considère l'espace comme trop grand pour être un espace entre deux mots et on coupe la fin de la colonne au niveau de \textit{endText}. \\
	
	\paragraph{}
	Le résultat de ce programme sur la photo précédente donne l'image ci-dessous, comportant en rouge les lignes tracées par la programme pour délimiter les colonnes, qui peuvent maintenant être coupées: \\
	
	$IMAGE\_AVEC\_LES\_LIGNES$
	
	\paragraph{}
	Comme vous pouvez le voir, quatre lignes sont créées: la première correspond au début de la première question, la deuxième à la fin de cette même colonne. Les deux autres représentent respectivement le début et la fin de la deuxième colonne. Bien entendu, ici, les colonnes sont juste découpées par des lignes, mais il faudrait les séparer en deux images différentes, ce qui est fait par une autre fonction de notre programme.
	
	\subsubsection{Découpage des paragraphes}
	\paragraph{}
	Cette partie est la suite logique du découpage des colonnes. En effet, en regardant l'image 1 précédemment affichée, chaque colonne contient plusieurs paragraphes nettement distinguables. Ainsi, un programme similaire est utilisé sur chaque colonne trouvée pour découper les différents paragraphes afin qu'ils soient traités plus tard.
	\par
	Ici, le changement est principalement basé sur le fait de regarder si la largeur de l'image est complètement blanche, contrairement à la hauteur pour les colonnes. De plus, on détermine ici si un paragraphe se termine en fonction de la "hauteur" de la dernière ligne/du dernier paragraphe trouvé. Voici le nouveau code pour ce type de segmentation: \\
	
	\begin{lstlisting}
    
    unsigned char fullWhite = 1;
    unsigned char firstCut = 1;
    int endText = -1; //Gets the first pixel (height wise) with full white width
    int beginingText = -1; //Gets the first pixel without full white width after several full white 
    int lastLineHeight = -1; //Stores the number of pixels from the last text line
    
		for (int i = 0; i < img -> w; i++) 
    {
        // Returns whether img's height is full of white pixels or not
        fullWhite = fullWhite(img, i);

        if (!fullWhite && firstCut)
        {   
            // Begins column cut
            beginingText = i;
            if (endText == -1 || (lastLineHeight <= abs(endText - beginingText)){
                for (int k = 0; k < img -> w; k++)
                {
                    pixel = SDL_MapRGB(img_copy -> format, 0, 255, 0);
                    putpixel(img_copy, k, beginingText, pixel);
                }   
            }
            firstCut = 0;
        }
        
        if(fullWhite && !firstCut) {
        
            // Ends column cut
            endText = i-1;
            lastLineHeight = endText - beginingText;
            int ii = i;
            do
            {
                fullWhite = fullWhite(img, ii);
                ii++;
            } while (fullWhite);
            
            if (ii - endText >= lastLineWidth || ii >= img -> h) {
                // Space is too big, draw line to separate
                for (int k = 0; k < img -> w; k++)
                {
                    pixel = SDL_MapRGB(img_copy -> format, 0, 255, 0);
                    putpixel(img_copy, k, i, pixel);
                }
            }
            firstCut = 1;
        }
    }	
	\end{lstlisting}
	
	\paragraph{}
	Le résultat de ce nouveau programme, combiné à une fonction qui retire les lignes vertes créées, découpe et stocke les paragraphes dans de nouvelles images donne le résultat suivant: 
	
	$IMAGES\_DES\_PARAGRAPHES\_DECOUPES$
	
	\paragraph{}
	Les paragraphes sont parfaitement découpés et près à être traités par la suite du programme jusqu'à pouvoir arriver à détecter des caractères.
	
	\subsubsection{Découpage des lignes}
	\paragraph{}
	Le découpage des mots est l'étape suivante que nous avons créée. En effet, les paragraphes sont des blocs de lignes qu'il faut séparer.
	\par Cette partie ressemble très fortement, pour ne pas dire exactement, à la partie précédente. La seule différence apportée se situe au niveau de la tolérance de hauteur entre deux lignes. Pour détecter si on a bien affaire à un changement de ligne, il nous faut regarder l'espace entre la fin supposée de la ligne précédente et le début de la nouvelle. Si cet écart est trop faible, alors on ne considère pas la fin de ligne supposée comme une fin de ligne.
	
	\paragraph{}
	C'est justement le degré considération qui change par rapport au découpage des paragraphes. Ici, on considère un changement si l'écart détecter entre le début et la fin des supposées lignes est supérieur à 0.2 fois la hauteur d'une ligne, comparé à la hauteur elle-même pour la détection de paragraphes.
	\par Dans le code, cela revient à changer les conditions des lignes 17 et 39, on remplaçant \textit{lastLineHeight} par \textit{lastLineHeight * 0.2}. Tout comme le découpage des paragraphes, on dessine les lignes séparatrices puis découpe les lignes pour les stocker dans un dossier dédié. Voici le résultat du découpage des lignes par notre programme: \\
	
	$IMAGES\_DES\_LIGNES\_DECOUPES$
	
	\subsubsection{Découpage des mots et des caractères}
	\paragraph{}
	Nous présenter le découpage des mots et des caractères ensemble car ils sont effectués plus ou moins en même temps. En effet, le découpage des caractères reste une étape très délicate à appréhender car elle nécessite de prévoir ou doivent être découpés les caractères.
	
	\paragraph{}
	L'ordre des segmentations voudrait que les mots soient découpés en premiers, puis les caractères ensuite. Au final, c'est plus ou moins ce qui se passe: on dessine les lignes séparant chaque caractère, puis on découpe les mots de la même façon que l'on découpe les colonnes, et enfin on découpe les caractères en utilisant les lignes dessinées auparavant, pour chacun des mots.
	
	\paragraph{}
	Pourquoi faisons nous ces deux découpages en même temps? Tout simplement pour une question de précision sur le découpage des caractères. En effet, notre découpage des caractères se fait en fonction de la largeur moyenne d'un caractère de la phrase en cours de découpage.
	\par Pour être encore plus clair, voici ce qu'il se passe précisément. Nous définissons la largeur moyenne d'un caractère comme \textit{0.5 * (image -> h)}, soit la moitié de la hauteur de l'image (résultat basé sur une comparaison des largeurs moyennes de caractères pour plusieurs polices, celles-ci étant centrées autour de cette valeur). Ensuite, nous parcourons l'image de gauche à droite, c'est-à-dire que nous cherchons le début d'un caractère (tous les pixels ne sont pas blancs sur la hauteur de l'image), puis nous cherchons sa fin (tous les pixels sont blancs). Cette fin n'est pas forcément la bonne, car deux caractères peuvent se chevaucher.
	\par C'est alors qu'intervient notre variable de largeur moyenne d'un caractère. On regarde quelle largeur fait le supposé caractère sélectionné. S'il est x fois plus large que la moyenne, alors nous considérons que x caractères se chevauchent, et on coupe le bloc en x caractères différents. La moyenne est alors modifiée en fonction de la taille des caractères découpés.
	\par Voici pourquoi nous faisons le découpage des caractères avant celui des mots, car plus la phrase contient de caractères, plus on peut être précis sur la façon de les découper.
	
	\paragraph{}
	Voici à quoi ressemble le programme final pour le découpage des caractères:
	\begin{lstlisting}
	for (int j = 0; j < img -> w; j++)
    {
        fullWhite = fullWhiteHeight(img, j);
        if (!fullWhite && firstCut)
        {
            beginingCharPixel = j;

            /* Draw line for cut */

            firstCut = 0;
        }
        
        if(fullWhite && !firstCut) 
        {
            endingCharPixel = j-1;
            int actualCharLength = abs(endingCharPixel - beginingCharPixel);
            firstCut = 1;
            
            /* Draw line for cut */

            // Bloc is too long
            if (actualCharLength > 2*averageCharLength)
            {
                int times = round(actualCharLength/actualCharLength);
                int middle = actualCharLength/2 + beginingCharPixel;
                for (char k = 1; k <= times; k++){
                    
                    /* Draw line at beginingCharPixel + k*actualCharLength/times for cut */

                }
                nbChars += times;
                averageCharLength = (averageCharLength*(nbChars-times) + actualCharLength)/nbChars;
            }
            else {
                nbChars += 1;
                averageCharLength = (averageCharLength*(nbChars-1) + actualCharLength)/nbChars;
            }
        }
    }
	\end{lstlisting}
	
	\paragraph{}
	Comme dit précédemment, le découpage des mots est effectué après avoir dessiné les lignes pour celui des caractères. Ceci n'a pas d'impact sur son efficacité, et peut même aider au découpage car les espaces blancs entre les caractères ont été remplacés ou réduits avec les nouvelles lignes dessinées.
	
	\paragraph{}
	La même technique est utilisée pour découper colonnes et mots, on regarde quelle taille fait l'espace entre la supposée fin d'un mot et le début de l'autre. Après avoir fait des recherches, un espace représente environ 25\% de la hauteur des caractères. On utilise ainsi cette donnée pour vérifié si l'espace trouvé est supérieur à 22\% de la hauteur de l'image. Cet algorithme fonctionne très bien est découpe brillamment les mots. En voici un exemple: \\
	
	$IMAGES\_DES\_MOTS\_DECOUPES$
	
\newpage

\rhead{\textit{Réseau de neurones}\vspace{0.25cm}}
\section{Réseau de neurones}


\subsection{Fonction XOR}

\paragraph{} La première étape pour obtenir un bon réseau de neurones était de développer un réseau capable d'apprendre la fonction XOR. Cela a pour avantage que le réseau serait rapide à entraîner, le réseau n'a que 2 entrées pour une seule sortie, et seulement 4 motifs d'entrainements.

\begin{center}
\vspace*{0.2cm}
\begin{tabular}{|l|l|c|r|}
  \hline
  & entrée 1 & entrée 2 & sortie \\
  \hline
  Motif 1 & 0 & 0 & 0 \\
  Motif 2 & 0 & 1 & 1 \\
  Motif 3 & 1 & 0 & 1 \\
  Motif 4 & 1 & 1 & 0 \\
  \hline
\end{tabular}
\end{center}


\paragraph{}N'étant alors pas tout à fait à l'aise avec ce « nouveau » langage qu'est le C, j'ai d'abord cherché à faire ce réseau en Python, un langage que je maîtrise depuis plusieurs années. J'ai donc cherché de l'aide et des exemples de réseaux de neurones par rétropropagation en Python, mais la plupart des résultats utilisaient le module Numpy pour la manipulation de matrice ainsi que certains calculs, or, en C, tout cela doit être traité manuellement.

\paragraph{}Après plusieurs heures de recherche, je suis tombé sur un très bon tutoriel qui expliquait en détail le fonctionnement d'un tel programme, avec des exemples en C++. J'ai facilement réussi à refaire le programme en Python, puis en C.

\paragraph{}Ensuite, pour voir si un tel réseau était adaptable à d'autres algorithmes, j'ai essayé de lui faire apprendre d'autres motifs, comme une fonction qui à partir de trois entrées, renvoie 1 si au moins 2 sont à 1 (et 0 sinon).

\subsection{Reconnaissance de caractères}

\paragraph{}Une seconde étape était de prévoir une structure pour notre réseau de neurones.
Au final, le réseau qui apprendra à reconnaître des caractères est un réseau semblable à notre réseau XOR, avec un nombre d'entrées égal à nombre de pixel dans une image, et le nombre de sorties serait égal au nombre de caractères à reconnaître.

\paragraph{}Les entrées sont des doubles compris entre 0 et 1, un 0 correspond à un pixel dont la couleur est celle du fond de l'image, un 1 correspond à un pixel de la couleur d'écriture du caractère.

\paragraph{}Les images qui lui seront transmises auront une taille de 32×32 et seront collées au coin supérieur gauche. Le réseau a donc 1024 entrées.

\paragraph{}Le nombre de sorties est égal au nombre de caractères à reconnaître. On suppose donc que la sortie ayant la plus grande valeur correspond au caractère reconnu.

\paragraph{} Dès la réception du cahier des charges le 10 septembre, j'ai écris un programme C qui à l'aide de SDL2, lit des images et enregistre la valeur des pixels dans un tableau. Ce programme est encore utilisé aujourd'hui, mais sera surement modifié d'ici à la fin du projet pour mieux correspondre avec le traitement de l'image effectué par mes camarades.

\paragraph{}Ensuite, il nous fallait un catalogue d'images (dataset) qui pourrait être utilisé pour l'entraînement et les tests du réseau. Les catalogues trouvés sur internet étaient très limités (taille des images ne correspondant pas, trop peu d'images,…), la meilleure solution était de créer nos propres datasets.

\paragraph{}Pour cela, j'ai écris un petit script en Python qui génère des images avec un caractère dessus (grâce à la bibliothèque PIL). La police, couleur et taille sont aléatoires afin d'obtenir un entraînement plus diversifié.

\paragraph{}Le premier réseau devait apprendre à reconnaître les caractères numériques 0 à 9. Les résultats n'étaient au début pas très probants. Et pour cause: les poids et biais des neurones étaient mal initialisés (Ils étaient initialisés entre 0 et 1 au lieu de entre -0.5 et 0.5). Une fois ce problème corrigé, le réseau arrivait à apprendre et reconnaissait les caractères avec une précision de 67\% environ. Deux problèmes se posaient alors:

\begin{itemize}
	\item Le réseau ne montait pas au dessus de 67\% de réussite
	\item Il avait besoin de beaucoup de neurones (plus de 1000) dans sa couche intermédiaire.
\end{itemize}

\paragraph{} Ces problèmes m'ont pas mal pris la tête, et m'ont obligé à revoir l'ensemble du programme.
Au bout de deux semaines de migraines, l'origine du problème m'est apparue: la dérivée de la fonction Sigmoïde était mal implémentée.

La dérivée de la sigmoïde s'écrit comme ceci:

\begin{center}
	$\frac{d\sigma(x)}{dx} = \sigma(x)\dot{}(1 - \sigma(x))$
\end{center}

\paragraph{}Or, les paramètres récupérés et qui passent dans cette fonction sont déjà $\sigma(x)$. Du coup, la dérivée était au final calculée comme $\sigma(\sigma(x))\dot{}(1 - \sigma(\sigma(x)))$

\paragraph{}Une fois ce problème résolu, on a obtenu des résultats proches de 95\% pour une couche intermédiaire de seulement 760 neurones.


\subsection{Scripting}

\paragraph{}Une fois que j'étais sûr que le réseau était bien en train d'apprendre, je me suis chargé du scripting, c'est à dire de créer des structs et des fonctions qui permettent d'interagir avec le réseau plutôt que de tout avoir dans un même fichier .c.

Le réseau de neurones tourne donc autour de deux structs: 

\begin{itemize}
	\item MMImage est une struct qui contient toutes les informations caractérisant une image pour une prédiction (dimensions de l'image, valeurs des pixels, …) ou le training (caractère que c'est vraiment, …)
	\item MMNetwork, qui contient les informations à propos d'un réseau de neurones (nombre d'entrées, sorties, neurones, les poids et les biais)
\end{itemize}

\paragraph{}J'ai implémenté des fonctions autour de ces structs, comme la fonction LoadDataset, qui permet de charger un dataset complet en mémoire, ou LoadImage qui permet de ne charger qu'une seule image.

\begin{lstlisting}
MMImage*		LoadDataset(int noChars, int imagesPerChar);
MMImage		LoadImage(char* path);
\end{lstlisting}

\paragraph{}Concernant MMNetwork, on peut initialiser un réseau grâce à la fonction InitNetwork.
Pour libérer la mémoire, on a la fonction DestroyNetwork.

\begin{lstlisting}
MMNetwork InitNetwork(unsigned int numInputs, unsigned short numHiddenNodes, unsigned int numOutputs);
void DestroyNetwork(struct MMNetwork n);

\end{lstlisting}

\paragraph{}L'avantage de MMNetwork, c'est qu'il peut être enregistré et chargé dans des fichiers. Cela sert notamment à sauvegarder l'état d'un réseau enregistré pour pouvoir le récupérer ensuite pour faire les prédictions.

\begin{lstlisting}
void SaveNetwork(MMNetwork n, char* path);
MMNetwork LoadNetwork(char* path);
\end{lstlisting}


\paragraph{}
À partir de là, les bases sont posées pour effectuer n'importe quel type d'opérations avec les réseaux. En effet, une simple prédiction peut se faire avec la fonction Predict, qui à partir d'un MMImage et d'un MMNetwork, renvoie les valeurs de la couche de sortie du réseau, qui peut être analysée par la fonction OutputChar.

\begin{lstlisting}
double*	Predict(MMNetwork network, const MMImage* image);
char OutputChar(double* outputLayer);
\end{lstlisting}


\textbf{Exemple de programme:}

\paragraph{}Analysons maintenant le programme suivant, qui permet de prédire le caractère présent sur une image:

\begin{center}
	\includegraphics[scale=0.8]{maxime1}
\end{center}


\begin{itemize}
	\item Ligne 6: on charge une image à partir de son chemin d'accès dans une variable img
	\item Ligne 7: On charge le réseau précédemment entraîné à partir du chemin où il a été enregistré dans une variable n
	\item Ligne 9: On fait une prédiction sur l'image img par le réseau n. Les valeurs de la couche de sortie sont enregistrées dans une variable output.
	\item Ligne 10: À partir de la couche de sortie output, on récupère le caractère correspondant. C'est ce caractère qui est écrit sur l'image.
\end{itemize}

\paragraph{}Juste ces 4 lignes permettent de faire une prédiction sur le caractère écrit sur une image.

\newpage

\subsection{Fonctionnement du réseau}

\paragraph{}L'apprentissage du réseau utilise un algorithme du gardient stochastique (Stochastic Gradient Descent), une "variante" de la descente du gradient qui a pour particularité de l'utiliser qu'un seul élément (en l'occurrence une image) choisi aléatoirement du training-set à la fois pour modifier les poids. (Un algorithme standard de descente du gradient utilisera tous les éléments en même temps).

\paragraph{}Voici un schéma simplifié de notre réseau.
(Le réseau comporte 1024 entrées, 760 neurones cachés, et 78 sorties. Pour des raisons de clarté, je n'ai représenté que certains d'entre eux.)

\begin{center}
	\includegraphics[scale=0.5]{Neuron}
\end{center}

\paragraph{}Chaque entrée influera sur chaque neurone caché par l'intermédiaire d'un poids caché (hidden weight) et du biais du neurone caché.
De même, chaque neurone caché influera sur chaque neurone de sortie par l'intermédiaire d'un poids de sortie (output weight) et du biais du neurone de sortie.
À chaque itération de l'apprentissage, une valeur est calculée pour chaque neurone caché et chaque neurone de sortie par

\begin{center}
	$hiddenLayer_j=\sigma(hiddenLayerBias_j+\sum input_i\times hiddenWeight_{i\rightarrow j})$
	\vspace*{0.3cm}
	$outputLayer_j=\sigma(outputLayerBias_j+\sum hiddenLayer_k\times outputWeight_{j\rightarrow k})$
	\includegraphics[scale=0.5]{Meme}
\end{center}

\newpage
\rhead{\textit{Correcteur orthographique}\vspace{0.25cm}}
\section{Correcteur orthographique}

\newpage
\rhead{\textit{Command parser}\vspace{0.25cm}}
\section{Command parser}

\subsection{L'objectif}

\paragraph{}Notre but ici était de permettre l'utilisation de notre programme via des lignes de commandes dans un premier temps avant de réaliser l'interface graphique.

\paragraph{}Nous avons donc ajouté 3 commandes qui permettent d'exécuter des fonctionnalités clés telles que nos filtres, notre niveau de gris ainsi que la segmentation d'une image quelconque.

\subsection{Grayscale}

\paragraph{}C'est une fonction qui a besoin de 2 paramètres, le premier est le chemin de l'image d'origine et le deuxième le chemin auquel l'image en niveau de gris sera sauvegardée. Si les deux paramètres ne sont pas entrés ou bien que l'image entrée en paramètre ne peut être chargée, le programme s'arrête et renvoie un message d'erreur.

\begin{lstlisting}

	if (argc == 4) {
		SDL_Surface *imgDefault;
		imgDefault = SDL_LoadBMP(argv[2]);
		if (!imgDefault) {
			printf("Error: unable to find bmp file at %s\n", argv[2]);
			return 1;
		}
		imgDefault = grayscale(imgDefault, 1, argv[3]);
		return 0;
	}
	else {
		printf("Lambda: Grayscale take exactly 2 parameters but was called with %i parameter(s)\n", argc - 2);
		return 1;
	}
\end{lstlisting}

\paragraph{}Ici, l'objectif est de couvrir tous les cas d'utilisation et d'éviter les crash de notre programme. Ainsi la fonction n'est appelée uniquement lorsque tous les paramètres sont entrés et la fonction grayscale renvoi un booléen indiquant qu'une erreur s'est produite pendant l'exécution et ainsi permet au parser de prévenir l'utilisateur.

\subsection{Filters}

\subsection{Segmentation}

La fonction de segmentation s'exécute avec simplement un paramètre: le chemin de l'image qu'il faut segmenter. Pour le reste, tout est géré via une architecture de dossiers et fichiers précise, l'utilisateur n'a pour l'instant pas le choix de ce dernier.

\begin{lstlisting}
	if (argc == 3) {
		if (!fullSegmentation(argv[2])) {
			printf("Lambda: Error during segmentation execution\n");
			return 1;
		}
		printf("Lambda: Segmentation ended successfully\n");
		return 0;
	}
	else {
		printf("Lambda: Segmentation take exactly 1 paramater but was called with %i parameter(s)\n", argc - 2);
		return 1;
	}
\end{lstlisting}

\newpage
\rhead{\textit{Avancement}\vspace{0.25cm}}
\section{Notre avancement et répartition des tâches}


\subsection{Répartition des tâches à la première soutenance}

\paragraph{} Nous vous avons présenté les fonctionnalités de notre projet sans dire qui était en charge de ces dernières. Ce tableau est le récapitulatif global de nos tâches respectives pour la première soutenance, le X signifie que la personne a participé à cette tâche. L'objectif ici est de clarifier nos rôles, nous formons un seul groupe qui progresse et se donne des objectifs en fonction des possibilités et envies de chacun. Le nombre de tâches réalisées n'a pas de rapport avec l'investissement dans le projet car la complexité est différente.
\begin{center}
\vspace*{0.2cm}
\begin{tabular}{|l|c|c|c|c|}
  \hline
  & Quentin & Maxime & Charles & Nathan \\
  \hline
  Pré-traitement & X &  & X &  \\
  \hline
  Segmentation de l'image & X &  & X &  \\
  \hline
  Réseau de neurones &  & X &  &  \\
  \hline
  Correcteur orthographique &  &  &  & X \\
  \hline
  Command parser &  &  & X &  \\
  \hline
\end{tabular}
\end{center}


\subsection{Nos objectifs et envies}

\paragraph{}La deuxième soutenance sera la dernière pour ce projet, il faut donc qu'il soit terminé d'ici là. Nous devons donc mettre tout en oeuvre pour lier la segmentation en caractères de notre image source avec la reconnaissance de ces derniers pour permettre à l'utilisateur de récupérer son texte.

\paragraph{}Il nous faut aussi commencer l'interface graphique pour donner vie à notre projet et lui faire dépasser le stade des lignes de commandes. Nous avons déjà commencé à utiliser pour GTK et Glade pour créer cette dernière et elle sera terminée pour la deuxième soutenance. L'objectif est créer une interface en adéquation avec le style graphique que nous avons mis au point pour le groupe.

\paragraph{}La finalisation du correcteur orthographique est une étape importante pour le projet. Elle ajouterai une fonctionnalité utile pour l'utilisateur. Cela nous apportera beaucoup dans la compréhension de l'implémentation d'un correcteur orthographique et sa réalisation et nous fera réfléchir à l'optimisation de notre programme pour ne pas perdre trop de temps sur la correction. 

\paragraph{}L'IA doit encore être entrainée pour avoir un taux d'erreur le plus bas possible et reconnaître au mieux les caractères de l'image. Il faut penser à la reconnaissance des accents, virgules, points, ...

\paragraph{}Nous devons aussi penser à améliorer notre segmentation des caractères pour éviter les problèmes auxquels nous sommes confrontés aujourd'hui et peut être créer un réseau de neurones qui pourrait apprendre à reconnaître des caractères sur une ligne grâce si nous avons le temps.

\newpage
\rhead{\textit{Conclusion}\vspace{0.25cm}}
\section{Conclusion}

\newpage


\end{document}
